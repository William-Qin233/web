<!--
 * @Author: WilliamQin
 * @Date: 2022-04-12 22:26:42
 * @LastEditors: WilliamQin
 * @LastEditTime: 2022-04-14 22:52:29
 * @Description: Array 相关方法
 * @FilePath: \web\JavaScript\Array相关方法\集合.md
 * Saying：AMD yes!
-->
数组的作为 JS 中的常见数据，大量应用于表格、小组件模块渲染、接口调用的数值传递，可以玩的骚操作很多。

# 常用的方法
`Array.prototype.concat()`、
# Array.prototype.at()
接收一个整数值，并返回该索引位置的，项目，允许证书和负数。负整数则从数组中的最后一项往前倒数。
```javascript
const array1 = [5, 12, 8, 130, 44];

let index = 2;

console.log(`Using an index of ${index} the item returned is ${array1.at(index)}`);
// expected output: "Using an index of 2 the item returned is 8"

index = -2;

console.log(`Using an index of ${index} item returned is ${array1.at(index)}`);
// expected output: "Using an index of -2 item returned is 130"
```
# Array.prototype.concat()
[Array.prototype.concat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)
`concat()`合并两个或多个数组，不会更改现有数组，而是返回一个新数组，也就是原有数组的引用地址不会改变。但是返回的是浅拷贝。

## Syntax
> `const newArray = oldArray.concat(value[, value[, ...[, value]]])`


## Parameters
valueN 可选
当省略 value 时，concat 方法会返回调用此方法的现存数组的一个浅拷贝

## Description
concat方法创建一个新的数组，它由被调用的对象中的元素组成，每个参数的顺序依次是该参数的元素（如果参数是数组）或参数本身（如果参数不是数组）。它不会递归到嵌套数组参数中。
concat方法不会改变this或任何作为参数提供的数组，而是返回一个浅拷贝，它包含与原始数组相结合的相同元素的副本。 原始数组的元素将复制到新数组中，如下所示：

- 对象引用（而不是实际对象）：concat将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。 也就是说，如果引用的对象被修改，则更改对于新数组和原始数组都是可见的。 这包括也是数组的数组参数的元素。
- 数据类型如字符串，数字和布尔（不是[String](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)，[Number](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number) 和 [Boolean](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) 对象）：concat将字符串和数字的值复制到新数组中。

简单说就是对于引用类型数据，只会进行浅拷贝：
```javascript
const obj1 = {a: 1, b: 2}
const arr1 = [1, obj1]
const arr2 = [2].concat(arr1)
console.log(arr2)  // [2, 1, {a: 2, b: 2}]
obj1.c = 3
console.log(arr2)  // [2, 1, {a: 2, b:2, c: 3}]
```
# Array.prototype.copyWithin()
**copyWithin()** 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。
```javascript
const array1 = ['a', 'b', 'c', 'd', 'e'];

// copy to index 0 the element at index 3
console.log(array1.copyWithin(0, 3, 4));
// expected output: Array ["d", "b", "c", "d", "e"]

// copy to index 1 all elements from index 3 to the end
console.log(array1.copyWithin(1, 3));
// expected output: Array ["d", "d", "e", "d", "e"]
```
# Array.prototype.fill()
`fill()`方法用固定的值填充一个数组中从起始索引 -> 终止索引内的全部元素。不包括终止索引，左闭右开。

和 copyWithin() 的区别是，fill() 不是数组内部挪移。
```javascript
const array1 = [1, 2, 3, 4];

// fill with 0 from position 2 until position 4
console.log(array1.fill(0, 2, 4));
// expected output: [1, 2, 0, 0]

// fill with 5 from position 1
console.log(array1.fill(5, 1));
// expected output: [1, 5, 5, 5]

console.log(array1.fill(6));
// expected output: [6, 6, 6, 6]
```
# Array.prototype.entries()
`entries()`方法返回一个新的 Array Iterator 对象，该对象包含数组中每个索引的键/值对。
```javascript
const array1 = ['a', 'b', 'c'];

const iterator1 = array1.entries();

console.log(iterator1.next().value);
// expected output: Array [0, "a"]

console.log(iterator1.next().value);
// expected output: Array [1, "b"]
```
换个说法，其实就是把链表在 JS 中实现了。

## Syntax
> `arr.entries()`

## Example

1. Array Iterator
```javascript
var arr = ["a", "b", "c"];
var iterator = arr.entries();
console.log(iterator);

/*Array Iterator {}
         __proto__:Array Iterator
         next:ƒ next()
         Symbol(Symbol.toStringTag):"Array Iterator"
         __proto__:Object
*/
```

2. iterator.next()
```javascript
var arr = ["a", "b", "c"];
var iterator = arr.entries();
console.log(iterator.next());

/*{value: Array(2), done: false}
          done:false
          value:(2) [0, "a"]
           __proto__: Object
*/
// iterator.next()返回一个对象，对于有元素的数组，
// 是next{ value: Array(2), done: false }；
// next.done 用于指示迭代器是否完成：在每次迭代时进行更新而且都是false，
// 直到迭代器结束done才是true。
// next.value是一个["key","value"]的数组，是返回的迭代器中的元素值。
```

3. iterator.next方法运行
```javascript
var arr = ["a", "b", "c"];
var iter = arr.entries();
var a = [];

// for(var i=0; i< arr.length; i++){   // 实际使用的是这个
for(var i=0; i< arr.length+1; i++){    // 注意，是length+1，比数组的长度大
    var tem = iter.next();             // 每次迭代时更新next
    console.log(tem.done);             // 这里可以看到更新后的done都是false
    if(tem.done !== true){             // 遍历迭代器结束done才是true
        console.log(tem.value);
        a[i]=tem.value;
    }
}

console.log(a);                         // 遍历完毕，输出next.value的数组
```

4. 二维数组按行排序
```javascript
function sortArr(arr) {
    var goNext = true;
    var entries = arr.entries();
    while (goNext) {
        var result = entries.next();
        if (result.done !== true) {
            result.value[1].sort((a, b) => a - b);
            goNext = true;
        } else {
            goNext = false;
        }
    }
    return arr;
}

var arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]];
sortArr(arr);

/*(4) [Array(2), Array(5), Array(5), Array(4)]
    0:(2) [1, 34]
    1:(5) [2, 3, 44, 234, 456]
    2:(5) [1, 4, 5, 6, 4567]
    3:(4) [1, 23, 34, 78]
    length:4
    __proto__:Array(0)
*/
```

5. 使用 for...of 循环
```javascript
var arr = ["a", "b", "c"];
var iterator = arr.entries();
// undefined

for (let e of iterator) {
    console.log(e);
}

// [0, "a"]
// [1, "b"]
// [2, "c"]
```
# Array.prototype.every()
`every()`方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。返回一个布尔值。
```javascript
const isBelowThreshold = (currentValue) => currentValue < 40;

const array1 = [1, 30, 39, 29, 10, 13];

console.log(array1.every(isBelowThreshold));
// expected output: true
```
## Syntax
> `arr.every(callback(element[, index[, array]])[, thisArg])`

## Parameter
`callback`
用来测试每个元素的函数，它可以接收三个参数：
`element`
用于测试的当前值。
`index可选`
用于测试的当前值的索引。
`array可选`
调用 every 的当前数组。

`thisArg`
执行 callback 时使用的 this 值。
## Return value
如果回调函数的每一次返回都为 [truthy](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy) 值，返回 `true` ，否则返回 `false`。
若收到一个空数组，此方法在一切情况下都会返回 `true`。

## Description
every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 [falsy](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy) 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从未被赋值的索引调用。
callback 在被调用时可传入三个参数：元素值，元素的索引，原数组。
如果为 every 提供一个 thisArg 参数，则该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。详见 [this](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this) 条目。
every 不会改变原数组。
every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。
every 和数学中的"所有"类似，当所有的元素都符合条件才会返回true。正因如此，若传入一个空数组，无论如何都会返回 true。（这种情况属于[无条件正确](http://en.wikipedia.org/wiki/Vacuous_truth)：正因为一个[空集合](https://en.wikipedia.org/wiki/Empty_set#Properties)没有元素，所以它其中的所有元素都符合给定的条件。)

- 只有都满足条件（callback函数）时，才会返回 `true`，遇到一个不满足条件的，会直接返回 `false`；
- 不改变原数组；
- 空数组 `[]`调用 every 会直接返回`true`。
## Example

- 检测所有数组元素的大小
```javascript
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough);   // false
[12, 54, 18, 130, 44].every(isBigEnough); // true
```

- 使用箭头函数

[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)为上面的检测过程提供了更简短的语法。
```javascript
[12, 5, 8, 130, 44].every(x => x >= 10); // false
[12, 54, 18, 130, 44].every(x => x >= 10); // true
```
## Polyfill
该算法是 ECMA-262 第 5 版中指定的算法，它假定 Object 和 TypeError 拥有它们的初始值，且 fun.call 等价于 [Function.prototype.call](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)。
```javascript
if (!Array.prototype.every) {
  Array.prototype.every = function(callbackfn, thisArg) {
    'use strict';
    var T, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the this
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal method
    //    of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (typeof callbackfn !== 'function') {
      throw new TypeError();
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0.
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal method
        //    of O with argument Pk.
        kValue = O[k];

        // ii. Let testResult be the result of calling the Call internal method
        //     of callbackfn with T as the this value and argument list
        //     containing kValue, k, and O.
        var testResult = callbackfn.call(T, kValue, k, O);

        // iii. If ToBoolean(testResult) is false, return false.
        if (!testResult) {
          return false;
        }
      }
      k++;
    }
    return true;
  };
}
```
# Array.prototype.filter()
[Array.prototype.filter()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
`filter()`方法创建一个新数组，包含通过所传入的函数测试的所有的元素。
filter 即过滤，过滤出数组中所有符合函数测试（函数需要返回 true ）的项目。
## Try it
```javascript
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word => word.length > 6);

console.log(result);
// expected output: Array ["exuberant", "destruction", "present"]
```
## Syntax
> `const newArray = arr.filter(callback(element[, index[, array]]))[, thisArg]`

## Parameter
`callback`

- 用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。它接受以下三个参数：

`element`

   - 数组中当前正在处理的元素。

`index可选`

   - 正在处理的元素在数组中的索引。

`array可选`

   - 调用了 filter 的数组本身。

`thisArg可选`

- 执行 callback 时，用于 this 的值。
## Return value
一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。

## Example
### 利用 `filter` 去重
```javascript
function myUnique(arr) {
  const resArr = arr.filter((item, index, array) => {
    return array.indexOf(item) === index;
  })
  
  return resArr;
}


var a = [1, 1, '1', '2', 1];
var ans = unique(a);
console.log(ans);//[1, '1', '2',]
```
# Array.prototype.find()
`find()`方法返回数组中满足提供的测试函数的第一个元素的值。否则返回`undefined`。
 find 即查找，找到符合条件的第一个元素，不会返回所有符合条件的元素。如果想要找到所有符合条件的元素，可以使用上面的 filter() 函数
## Try it
```javascript
const array1 = [5, 12, 8, 130, 44];

const found = array1.find(element => element > 10);

console.log(found);
// expected output: 12
```
另请参见  `[findIndex()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)` 方法，它返回数组中找到的元素的索引，而不是其值。
如果你需要找到一个元素的位置或者一个元素是否存在于数组中，使用`[Array.prototype.indexOf()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)` 或 `[Array.prototype.includes()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)`。
Array.prototype.indexOf() 返回查找元素的下标，如果没有则返回 `-1`；
Array.prototype.includes() 返回 boolean 值，存在则返回 true，不存在则返回false。
## Syntax
> `arr.find(callback[, thisArg])`

## Parameter
`callback`

- 在数组每一项上执行的函数，接收 3 个参数：

`element`

   - 当前遍历到的元素。

`index可选`

   - 当前遍历到的索引。

`array可选`

   - 数组本身。

`thisArg可选`

- 执行回调时用作this 的对象。
## Return value
数组中第一个满足所提供测试函数的元素的值，否则返回 [undefined](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。
# Array.prototype.findIndex()
`findIndex()`方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。
## Try it
```javascript
const array1 = [5, 12, 8, 130, 44];

const isLargeNumber = (element) => element > 13;

console.log(array1.findIndex(isLargeNumber));
// expected output: 3
```
## Syntax
> `_arr_.findIndex(_callback_[, _thisArg_])`

## Parameter
`callback`

- 在数组每一项上执行的函数，接收 3 个参数：

`element`

   - 当前遍历到的元素。

`index可选`

   - 当前遍历到的索引。

`array可选`

   - 数组本身。

`thisArg可选`

- 执行回调时用作this 的对象。
## Return value
数组中通过提供测试函数的第一个元素的索引。否则，返回-1

# Array.prototype.flat()
flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。
## Try it
```javascript
const arr1 = [0, 1, 2, [3, 4]];

console.log(arr1.flat());
// expected output: [0, 1, 2, 3, 4]

const arr2 = [0, 1, 2, [[[3, 4]]]];

console.log(arr2.flat(2));
// expected output: [0, 1, 2, [3, 4]]
```
## Syntax
> `const newArray = arr.flat([depth])`

## Parameters
`depth 可选`
指定要提取嵌套数组的结构深度，默认值为 1。
## Return value
一个包含将数组与子数组中所有元素的新数组。
## Examples
### 扁平化嵌套数组
```javascript
var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

//使用 Infinity，可展开任意深度的嵌套数组
var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```















